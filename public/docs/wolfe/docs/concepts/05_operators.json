{
  "name" : "Operators",
  "cells" : [ {
    "id" : 4,
    "compiler" : "markdown",
    "input" : {
      "code" : "The previous sections have shown how Scala and Wolfe can be used\nto develop the building blocks of machine learning models. \nTo do inference and learning with such models we require mathematical operators\nthat interfact with the building blocks we introduced earlier. \n\nMost wolfe operators have the form\n$$\n\\DeclareMathOperator{\\operator}{operator}\n\\operator\\_{s \\in \\mathcal{S}: c(s) } f(s)\n$$\nwhere \\\\(\\mathcal{S}\\\\) is a collection of possible worlds, \\\\(c(\\cdot)\\\\)\na constraint on possible worlds, and \\\\(f\\\\) a scalar function. \nThe previous sections have shown how these components can be implemented,\nnow we can put them together. You may test this in the examples below\nby replacing `def` with `val` definitions.\n\n\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 7,
    "compiler" : "heading3",
    "input" : {
      "code" : "Restrictions",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 8,
    "compiler" : "markdown",
    "input" : {
      "code" : "When models interact with operators the __restrictions of Wolfe__ with respect\nto possible worlds, constraints and functions will become apparent. While you can \nuse any Scala expression to define these building blocks, only for a subset \nof these Wolfe operators can be implemented efficiently. This is partly \nbecause the internal matching algorithms lack coverage, and partly because\nthey are certainly models for which there simply is not effective algorithm, even\nif they can be matched. At least for the coverage problem we hope to continuously\nimprove Wolfe. Moreover, Wolfe attempts to yield errors and warnings whenever building blocks are used\nthat cannot be optimized.  \n\nOne restriction is that collections of possible worlds, if not atomic, need to be defined\nusing `def` and not `val` (or used inline directly when the operator is called).\nIf `val` is used the collection effectively becomes atomic, and a lot of optimizations\ncannot be performed. \n\n",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 0,
    "compiler" : "heading3",
    "input" : {
      "code" : "Argmax",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 5,
    "compiler" : "markdown",
    "input" : {
      "code" : "Finding the argument that maximizes a function under some constraint is a fundamental \nproblem of machine learning and beyond.",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 6,
    "compiler" : "wolfe",
    "input" : {
      "code" : "case class World(x:Boolean, y:Boolean)\ndef worlds = all(World) {bools x bools}\nargmax(worlds filter (_.x)) {w => I(w.x == w.y)}",
      "outputFormat" : "wolfe",
      "extraFields" : null
    }
  }, {
    "id" : 1,
    "compiler" : "heading3",
    "input" : {
      "code" : "Sum",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 2,
    "compiler" : "heading3",
    "input" : {
      "code" : "Restrictions",
      "outputFormat" : "html",
      "extraFields" : null
    }
  }, {
    "id" : 3,
    "compiler" : "markdown",
    "input" : {
      "code" : "Blah",
      "outputFormat" : "html",
      "extraFields" : null
    }
  } ]
}
