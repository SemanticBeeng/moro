{
  "name" : "Matrix Factorization",
  "cells" : [ {
    "id" : 0,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "import ml.wolfe._\nimport ml.wolfe.term.TermImplicits._\nimport ml.wolfe.term._\nimport ml.wolfe.util.Math._\n\nimplicit val rand = new scala.util.Random(0)\nval K = 2\nval N = 3\nval M = 4\nval epochs = 100\nval alpha = 0.1\nval lambda = 0.1\n\n// set up data\n@domain case class Rating(pid: Int, mid: Int, score: Double)\nimplicit val Ratings = Rating.Values(Ints(0 until N), Ints(0 until M), Doubles)\n\nval positive = Set(0->0, 1->1, 0->1)\nval data = for(i <- 0 until N; j <- 0 until M) yield Rating(i, j, if(positive(i -> j)) 1.0 else 0.0)\nlazy val dataTerm = data.toConst\ndata.size",
      "extraFields" : {
        "aggregatedCells" : "[]"
      }
    }
  }, {
    "id" : 1,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\n//the set of possible parameters\n@domain case class Theta(persons: IndexedSeq[Vect], movies: IndexedSeq[Vect])\nimplicit val Thetas = Theta.Values(Seqs(Vectors(K), N), Seqs(Vectors(K), M))\nThetas.zero.toConst\n",
      "extraFields" : {
        "aggregatedCells" : "[\"import ml.wolfe._\\nimport ml.wolfe.term.TermImplicits._\\nimport ml.wolfe.term._\\nimport ml.wolfe.util.Math._\\n\\nimplicit val rand = new scala.util.Random(0)\\nval K = 2\\nval N = 3\\nval M = 4\\nval epochs = 100\\nval alpha = 0.1\\nval lambda = 0.1\\n\\n// set up data\\n@domain case class Rating(pid: Int, mid: Int, score: Double)\\nimplicit val Ratings = Rating.Values(Ints(0 until N), Ints(0 until M), Doubles)\\n\\nval positive = Set(0->0, 1->1, 0->1)\\nval data = for(i <- 0 until N; j <- 0 until M) yield Rating(i, j, if(positive(i -> j)) 1.0 else 0.0)\\nlazy val dataTerm = data.toConst\\ndata.size\"]"
      }
    }
  }, {
    "id" : 2,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "\ndef score(theta: Thetas.Term)(r: Ratings.Term) = theta.persons(r.pid) dot theta.movies(r.mid)\n\ndef regularize(theta: Thetas.Term)(r: Ratings.Term) = theta.persons(r.pid).l2() + theta.movies(r.mid).l2()\n\nRating(1,1, 0.0).toConst// set up learning\ndef loss(t: Thetas.Term) = sum(dataTerm) {\n    r => (r.score - score(t)(r))*(r.score - score(t)(r)) + lambda*regularize(t)(r)\n}\n\n1000",
      "extraFields" : {
        "aggregatedCells" : "[\"import ml.wolfe._\\nimport ml.wolfe.term.TermImplicits._\\nimport ml.wolfe.term._\\nimport ml.wolfe.util.Math._\\n\\nimplicit val rand = new scala.util.Random(0)\\nval K = 2\\nval N = 3\\nval M = 4\\nval epochs = 100\\nval alpha = 0.1\\nval lambda = 0.1\\n\\n// set up data\\n@domain case class Rating(pid: Int, mid: Int, score: Double)\\nimplicit val Ratings = Rating.Values(Ints(0 until N), Ints(0 until M), Doubles)\\n\\nval positive = Set(0->0, 1->1, 0->1)\\nval data = for(i <- 0 until N; j <- 0 until M) yield Rating(i, j, if(positive(i -> j)) 1.0 else 0.0)\\nlazy val dataTerm = data.toConst\\ndata.size\",\"\\n//the set of possible parameters\\n@domain case class Theta(persons: IndexedSeq[Vect], movies: IndexedSeq[Vect])\\nimplicit val Thetas = Theta.Values(Seqs(Vectors(K), N), Seqs(Vectors(K), M))\\nThetas.zero.toConst\\n\\ndef score(theta: Thetas.Term)(r: Ratings.Term) = theta.persons(r.pid) dot theta.movies(r.mid)\\n\\ndef regularize(theta: Thetas.Term)(r: Ratings.Term) = theta.persons(r.pid).l2() + theta.movies(r.mid).l2()\\n\\nRating(1,1, 0.0).toConst\"]"
      }
    }
  }, {
    "id" : 3,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// visualize results\nval init = Settings(Thetas.createRandomSetting(random.nextGaussian() * 0.1))\nval adaParams = AdaGradParameters(epochs = epochs, learningRate = alpha, initParams = init)\n\n//do the training (argmax is a term, so it needs to be evaluated to do the optimization)\nval thetaStar = argmax(Thetas)(t => loss(t).argmaxBy(Argmaxer.adaGrad(adaParams)))\nthetaStar.eval()",
      "extraFields" : {
        "aggregatedCells" : "[\"import ml.wolfe._\\nimport ml.wolfe.term.TermImplicits._\\nimport ml.wolfe.term._\\nimport ml.wolfe.util.Math._\\n\\nimplicit val rand = new scala.util.Random(0)\\nval K = 2\\nval N = 3\\nval M = 4\\nval epochs = 100\\nval alpha = 0.1\\nval lambda = 0.1\\n\\n// set up data\\n@domain case class Rating(pid: Int, mid: Int, score: Double)\\nimplicit val Ratings = Rating.Values(Ints(0 until N), Ints(0 until M), Doubles)\\n\\nval positive = Set(0->0, 1->1, 0->1)\\nval data = for(i <- 0 until N; j <- 0 until M) yield Rating(i, j, if(positive(i -> j)) 1.0 else 0.0)\\nlazy val dataTerm = data.toConst\\ndata.size\",\"\\n//the set of possible parameters\\n@domain case class Theta(persons: IndexedSeq[Vect], movies: IndexedSeq[Vect])\\nimplicit val Thetas = Theta.Values(Seqs(Vectors(K), N), Seqs(Vectors(K), M))\\nThetas.zero.toConst\\n\\ndef score(theta: Thetas.Term)(r: Ratings.Term) = theta.persons(r.pid) dot theta.movies(r.mid)\\n\\ndef regularize(theta: Thetas.Term)(r: Ratings.Term) = theta.persons(r.pid).l2() + theta.movies(r.mid).l2()\\n\\nRating(1,1, 0.0).toConst\",\"// set up learning\\ndef loss(t: Thetas.Term) = sum(dataTerm) {\\n    r => (r.score - score(t)(r))*(r.score - score(t)(r)) + lambda*regularize(t)(r)\\n}\\n\\n1000\"]"
      }
    }
  }, {
    "id" : 4,
    "compiler" : "scala",
    "input" : {
      "sessionId" : null,
      "code" : "// predict\nThetas.zero.toConst\n//def predict(person: Int, movie: Int) = score(thetaStar.eval().toConst)(Rating(person, movie, 0.0).toConst)\n//predict(0,1)",
      "extraFields" : {
        "aggregatedCells" : "[\"import ml.wolfe._\\nimport ml.wolfe.term.TermImplicits._\\nimport ml.wolfe.term._\\nimport ml.wolfe.util.Math._\\n\\nimplicit val rand = new scala.util.Random(0)\\nval K = 2\\nval N = 3\\nval M = 4\\nval epochs = 100\\nval alpha = 0.1\\nval lambda = 0.1\\n\\n// set up data\\n@domain case class Rating(pid: Int, mid: Int, score: Double)\\nimplicit val Ratings = Rating.Values(Ints(0 until N), Ints(0 until M), Doubles)\\n\\nval positive = Set(0->0, 1->1, 0->1)\\nval data = for(i <- 0 until N; j <- 0 until M) yield Rating(i, j, if(positive(i -> j)) 1.0 else 0.0)\\nlazy val dataTerm = data.toConst\\ndata.size\",\"\\n//the set of possible parameters\\n@domain case class Theta(persons: IndexedSeq[Vect], movies: IndexedSeq[Vect])\\nimplicit val Thetas = Theta.Values(Seqs(Vectors(K), N), Seqs(Vectors(K), M))\\nThetas.zero.toConst\\n\\ndef score(theta: Thetas.Term)(r: Ratings.Term) = theta.persons(r.pid) dot theta.movies(r.mid)\\n\\ndef regularize(theta: Thetas.Term)(r: Ratings.Term) = theta.persons(r.pid).l2() + theta.movies(r.mid).l2()\\n\\nRating(1,1, 0.0).toConst\",\"// set up learning\\ndef loss(t: Thetas.Term) = sum(dataTerm) {\\n    r => (r.score - score(t)(r))*(r.score - score(t)(r)) + lambda*regularize(t)(r)\\n}\\n\\n1000\",\"// visualize results\\nval init = Settings(Thetas.createRandomSetting(random.nextGaussian() * 0.1))\\nval adaParams = AdaGradParameters(epochs = epochs, learningRate = alpha, initParams = init)\\n\\n//do the training (argmax is a term, so it needs to be evaluated to do the optimization)\\nval thetaStar = argmax(Thetas)(t => loss(t).argmaxBy(Argmaxer.adaGrad(adaParams)))\\nthetaStar.eval()\"]"
      }
    }
  } ],
  "config" : { }
}
